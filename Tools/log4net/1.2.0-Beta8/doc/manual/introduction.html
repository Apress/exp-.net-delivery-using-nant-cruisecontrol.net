<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//w3c//dtd xhtml 1.1 strict//en" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<link href="style.css" type="text/css" rel="STYLESHEET" />
		<title>log4net - Introduction</title>
	</head>
	<body>
		<div id="header"><h1>log4net - Introduction</h1></div>
		<div id="content">
			<h2>Contents</h2>
			<div class="i1">
				<a href="#overview">Overview</a><br/>
				<a href="#frameworks">Frameworks</a><br/>
				<a href="#loggers-and-appenders">Loggers and Appenders</a><br/>
				<div class="i1">
					<a href="#loggers-and-appenders.logger">Logger hierarchy</a><br/>
					<a href="#loggers-and-appenders.appenders">Appenders</a><br/>
					<a href="#loggers-and-appenders.filters">Filters</a><br/>
					<a href="#loggers-and-appenders.layouts">Layouts</a><br/>
					<a href="#loggers-and-appenders.or">Object Renderers</a><br/>
				</div>
				<a href="#configuration">Configuration</a><br/>
				<div class="i1">
					<a href="#configuration.attr">Configuration Attributes</a><br/>
					<a href="#configuration.files">Configuration Files</a><br/>
					<div class="i1">
						<a href="#configuration.files.config">.config Files</a><br/>
						<a href="#configuration.files.direct">Reading Files Directly</a><br/>
					</div>
					<a href="#configuration.syntax">Configuration Syntax</a><br/>
					<div class="i1">
						<a href="#configuration.syntax.appender">Appenders</a><br/>
						<div class="i1">
							<a href="#configuration.syntax.appender.filter">Filters</a><br/>
							<a href="#configuration.syntax.appender.layout">Layouts</a><br/>
						</div>
						<a href="#configuration.syntax.root">Root Logger</a><br/>
						<a href="#configuration.syntax.logger">Loggers</a><br/>
						<a href="#configuration.syntax.renderer">Renderers</a><br/>
						<a href="#configuration.syntax.param">Parameters</a><br/>
						<div class="i1">
							<a href="#configuration.syntax.param.compact">Compact Parameter Syntax</a><br/>
						</div>
					</div>
				</div>
				<a href="#ndc">Nested Diagnostic Contexts</a><br/>
				<a href="#mdc">Mapped Diagnostic Contexts</a><br/>
				<a href="#plugins">Plugins</a><br/>
				<a href="#performance">Performance</a><br/>
				<a href="#domains">Logging Domains</a><br/>
				<a href="#logging-flow">Logging Event Flow</a><br/>
				<a href="#more-info">More Information</a><br/>
			</div>
			<h2><a id="overview"></a>Overview</h2>
			<div class="i1">
				<p>
					This document is based on <i>Short introduction to log4j</i> by <i>Ceki G&uuml;lc&uuml;</i>.
				</p>
				<p>
					The log4net framework is based on log4j, see <a href="http://jakarta.apache.org/log4j">
						http://jakarta.apache.org/log4j</a> for more information on log4j.<br />
					The log4net framework, source code, binaries, documentation, examples and related 
					materials are published under the terms of the 
					Apache Software License version 1.1, a copy of which has been included with 
					this distribution in the LICENSE.txt file.
				</p>
				<p>
					This document is an introduction to the log4net API, its unique features and 
					design rationale. Log4net is an open source project based on the work of many 
					authors. It allows the developer to control which log statements are output 
					with arbitrary granularity. It is fully configurable at runtime using external 
					configuration files.
				</p>
				<p>
					Almost every large application includes its own logging or tracing API. 
					Inserting log statements into code is a low-tech method for debugging it. It 
					may also be the only way because debuggers are not always available or 
					applicable. This is usually the case for multithreaded applications and 
					distributed applications at large.
				</p>
				<p>
					Once an application has been deployed it may not be possible to utilise 
					development and debugging tools. An administrator can use effective logging 
					systems to diagnose and fix many configuration issues.
				</p>
				<p>
					Experience indicates that logging is an important component of the development 
					cycle. It offers several advantages. It provides precise <i>context</i> about the 
					execution of the application. Once inserted into the code, the generation of 
					logging output requires no human intervention. Moreover, log output can be 
					saved in persistent medium to be studied at a later time. In addition to its 
					use in the development cycle, a sufficiently rich logging package can also be 
					viewed as an auditing tool.
				</p>
				<p>
					Logging does have its drawbacks. It can slow down an application. If too 
					verbose, it can cause scrolling blindness. To alleviate these concerns, log4net 
					is designed to be reliable, fast and extensible. Since logging is rarely the 
					main focus of an application, the log4net API strives to be simple to 
					understand and to use.
				</p>
			</div>
			<h2><a id="frameworks"></a>Frameworks</h2>
			<div class="i1">
				<p>
					Log4net is available for several frameworks. For each supported framework an 
					assembly targeting that framework is built:
				</p>
				<ul>
					<li>Microsoft .Net Framework 1.0 (1.0.3705)</li>
					<li>Microsoft .Net Framework 1.1 (1.1.4322)</li>
					<li>Microsoft .Net Compact Framework 1.0 (1.0.5000)</li>
					<li>Mono 0.25</li>
					<li>Microsoft Shared Source CLI 1.0</li>
				</ul>
				<p>
					Not all frameworks are created equal and some features have been excluded from 
					some of the builds. See the <a href="framework-support.html">Framework Support</a> 
					document for more information.
				</p>
			</div>
			<h2><a id="loggers-and-appenders"></a>Loggers and Appenders</h2>
			<div class="i1">
				<p>
					Log4net has three main components: <i>loggers</i>, <i>appenders</i> and <i>layouts</i>. 
					These three types of components work together to enable developers to log 
					messages according to message type and level, and to control at runtime how 
					these messages are formatted and where they are reported. These components are
					helped by <i>filters</i> that control the actions of the appender and
					<i>object renderers</i> that turn objects into strings.
				</p>
				<h3><a id="loggers-and-appenders.logger"></a>Logger hierarchy</h3>
				<div class="i1">
					<p>
						The first and foremost advantage of any logging API over plain
						<span class="code">System.Console.WriteLine</span>
						resides in its ability to disable certain log statements while allowing others 
						to print unhindered. This capability assumes that the logging space, that is, 
						the space of all possible logging statements, is categorized according to some 
						developer-chosen criteria.
					</p>
					<p>
						Loggers are named entities. Logger names are case-sensitive and they follow the 
						hierarchical naming rule:
					</p>
					<dl class="rule">
						<dt>Named Hierarchy</dt>
						<dd>
							<p>
								A logger is said to be an <i>ancestor</i> of another logger if its name 
								followed by a dot is a prefix of the <i>descendant</i> logger name. A logger is 
								said to be a <i>parent</i> of a <i>child</i> logger if there are no ancestors 
								between itself and the descendant logger.
							</p>
							<p>
								The hierarchy works very much in the same way as the namespace and class 
								hierarchy in .NET. This is very convenient as we shall soon see.
							</p>
						</dd>
					</dl>
					<p>
						For example, the logger named
						<span class="code">"Foo.Bar"</span>
						is a parent of the logger named
						<span class="code">"Foo.Bar.Baz"</span>. Similarly,
						<span class="code">"System"</span>
						is a parent of
						<span class="code">"System.Text"</span>
						and an ancestor of
						<span class="code">"System.Text.StringBuilder"</span>. This naming scheme 
						should be familiar to most developers.
					</p>
					<p>
						The <i>root</i> logger resides at the top of the logger hierarchy. It is exceptional 
						in three ways:
					</p>
					<ol>
						<li>
							It always exists</li>
						<li>
							It cannot be retrieved by name</li>
						<li>
							It always has an assigned level</li>
					</ol>
					<p>
						Loggers are retrieved using the static method from the
						<span class="code">log4net.LogManager</span>
						class. The
						<span class="code">GetLogger</span>
						methods take the name of the desired logger as a parameter. They are listed 
						below:
					</p>
					<div class="syntax">
						<pre class="code">
namespace log4net
{
	public class LogManager
	{
		public static ILog GetLogger(string name);
		public static ILog GetLogger(Type type);
	}
}</pre>
					</div>
					<p>
						The
						<span class="code">GetLogger</span>
						methods that takes a
						<span class="code">Type</span>
						parameter uses the fully qualified type name as the name of the logger to 
						retrieve.
					</p>
					<p>
						These
						<span class="code">GetLogger</span>
						methods return an
						<span class="code">ILog</span>
						interface. That is the representation of the <i>Logger</i> passed back to the 
						developer. The
						<span class="code">ILog</span>
						interface is defined below:
					</p>
					<div class="syntax">
						<pre class="code">
namespace log4net
{
	public interface ILog
	{
		void Debug(object message);
		void Info(object message);
		void Warn(object message);
		void Error(object message);
		void Fatal(object message);
		
		void Debug(object message, Exception t);
		void Info(object message, Exception t);
		void Warn(object message, Exception t);
		void Error(object message, Exception t);
		void Fatal(object message, Exception t);

		bool IsDebugEnabled { get; }
		bool IsInfoEnabled { get; }
		bool IsWarnEnabled { get; }
		bool IsErrorEnabled { get; }
		bool IsFatalEnabled { get; }
	}
}</pre>
					</div>
					<p>
						Loggers <i>may</i> be assigned levels. Levels are instances of the
						<span class="code">log4net.spi.Level</span>
						class. The following levels are defined in order of increasing priority:
					</p>
					<ul>
						<li>
							<span class="code">ALL</span>
						</li>
						<li>
							<span class="code">DEBUG</span>
						</li>
						<li>
							<span class="code">INFO</span>
						</li>
						<li>
							<span class="code">WARN</span>
						</li>
						<li>
							<span class="code">ERROR</span>
						</li>
						<li>
							<span class="code">FATAL</span>
						</li>
						<li>
							<span class="code">OFF</span>
						</li>
					</ul>
					<p>
						If a given logger is not assigned a level, then it inherits one from its 
						closest ancestor with an assigned level. More formally:
					</p>
					<dl class="rule">
						<dt>Level Inheritance</dt>
						<dd>
							<p>
								The <i>inherited level</i> for a given logger <i>X</i>, is equal to the first 
								non-null level in the logger hierarchy, starting at <i>X</i> and proceeding 
								upwards in the hierarchy towards the <i>root</i> logger.
							</p>
						</dd>
					</dl>
					<p>
						To ensure that all loggers can eventually inherit a level, the <i>root</i> logger 
						always has an assigned level. The default value for the <i>root</i> logger is
						<span class="code">DEBUG</span>.
					</p>
					<p>
						Below are four tables with various assigned level values and the resulting 
						inherited levels according to the above rule.
					</p>
					<p>&nbsp;</p>
					<div class="table">
						<table cellspacing="0">
							<tr>
								<th>
									Logger name</th>
								<th>
									Assigned level</th>
								<th>
									Inherited level</th>
							</tr>
							<tr align="left">
								<td><i>root</i></td>
								<td>Proot</td>
								<td>Proot</td>
							</tr>
							<tr align="left">
								<td>X</td>
								<td>none</td>
								<td>Proot</td>
							</tr>
							<tr align="left">
								<td>X.Y</td>
								<td>none</td>
								<td>Proot</td>
							</tr>
							<tr align="left">
								<td>X.Y.Z</td>
								<td>none</td>
								<td>Proot</td>
							</tr>
						</table>
					</div>
					<p>
						In <i>Example 1</i> above, only the <i>root</i> logger is assigned a level. This level 
						value,
						<span class="code">Proot</span>, is inherited by the other loggers
						<span class="code">X</span>,
						<span class="code">X.Y</span>
						and
						<span class="code">X.Y.Z</span>.
					</p>
					<p>&nbsp;</p>
					<div class="table">
						<table cellspacing="0">
							<tr>
								<th>
									Logger name</th>
								<th>
									Assigned level</th>
								<th>
									Inherited level</th>
							</tr>
							<tr align="left">
								<td><i>root</i></td>
								<td>Proot</td>
								<td>Proot</td>
							</tr>
							<tr align="left">
								<td>X</td>
								<td>Px</td>
								<td>Px</td>
							</tr>
							<tr align="left">
								<td>X.Y</td>
								<td>Pxy</td>
								<td>Pxy</td>
							</tr>
							<tr align="left">
								<td>X.Y.Z</td>
								<td>Pxyz</td>
								<td>Pxyz</td>
							</tr>
						</table>
					</div>
					<p>
						In <i>Example 2</i> above, all loggers have an assigned level value. There is 
						no need for level inheritance.
					</p>
					<p>&nbsp;</p>
					<div class="table">
						<table cellspacing="0">
							<tr>
								<th>
									Logger name</th>
								<th>
									Assigned level</th>
								<th>
									Inherited level</th>
							</tr>
							<tr align="left">
								<td><i>root</i></td>
								<td>Proot</td>
								<td>Proot</td>
							</tr>
							<tr align="left">
								<td>X</td>
								<td>Px</td>
								<td>Px</td>
							</tr>
							<tr align="left">
								<td>X.Y</td>
								<td>none</td>
								<td>Px</td>
							</tr>
							<tr align="left">
								<td>X.Y.Z</td>
								<td>Pxyz</td>
								<td>Pxyz</td>
							</tr>
						</table>
					</div>
					<p>
						In <i>Example 3</i> above, the loggers
						<i>root</i>,
						<span class="code">X</span>
						and
						<span class="code">X.Y.Z</span>
						are assigned the levels
						<span class="code">Proot</span>,
						<span class="code">Px</span>
						and
						<span class="code">Pxyz</span>
						respectively. The logger
						<span class="code">X.Y</span>
						inherits its level value from its parent
						<span class="code">X</span>.
					</p>
					<p>&nbsp;</p>
					<div class="table">
						<table cellspacing="0">
							<tr>
								<th>
									Logger name</th>
								<th>
									Assigned level</th>
								<th>
									Inherited level</th>
							</tr>
							<tr align="left">
								<td><i>root</i></td>
								<td>Proot</td>
								<td>Proot</td>
							</tr>
							<tr align="left">
								<td>X</td>
								<td>Px</td>
								<td>Px</td>
							</tr>
							<tr align="left">
								<td>X.Y</td>
								<td>none</td>
								<td>Px</td>
							</tr>
							<tr align="left">
								<td>X.Y.Z</td>
								<td>none</td>
								<td>Px</td>
							</tr>
						</table>
					</div>
					<p>
						In <i>Example 4</i> above, the loggers <i>root</i> and
						<span class="code">X</span>
						and are assigned the levels
						<span class="code">Proot</span>
						and
						<span class="code">Px</span>
						respectively. The loggers
						<span class="code">X.Y</span>
						and
						<span class="code">X.Y.Z</span>
						inherits their level value from their nearest parent
						<span class="code">X</span>
						having an assigned level.
					</p>
					<p>
						Logging requests are made by invoking one of the printing methods of a logger 
						instance (through the <span class="code">log4net.ILog</span>). These printing methods are
						<span class="code">Debug</span>,
						<span class="code">Info</span>,
						<span class="code">Warn</span>,
						<span class="code">Error</span>, and
						<span class="code">Fatal</span>.
					</p>
					<p>
						By definition, the printing method determines the level of a logging request. 
						For example, if
						<span class="code">log</span>
						is a logger instance, then the statement
						<span class="code">log.Info("..")</span>
						is a logging request of level <span class="code">INFO</span>.
					</p>
					<p>
						A logging request is said to be <i>enabled</i> if its level is higher than or 
						equal to the level of its logger. Otherwise, the request is said to be <i>disabled</i>. 
						A logger without an assigned level will inherit one from the hierarchy. This 
						rule is summarized below.
					</p>
					<dl class="rule">
						<dt>Basic Selection Rule</dt>
						<dd>
							<p>
								A log request of level <i>L</i> in a logger with (either assigned or inherited, 
								whichever is appropriate) level <i>K</i>, is enabled if <i>L &gt;= K</i>.
							</p>
						</dd>
					</dl>
					<p>
						This rule is at the heart of log4net. It assumes that levels are ordered. For 
						the standard levels, we have
						<span class="code">DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</span>.
					</p>
					<p>
						Calling the
						<span class="code">log4net.LogManager.GetLogger</span>
						method with the same name will always return a reference to the exact same 
						logger object.
					</p>
					<p>
						For example, in:
					</p>
					<pre class="code">
ILog x = LogManager.GetLogger("wombat");
ILog y = LogManager.GetLogger("wombat");</pre>
					<p>
						<span class="code">x</span>
						and
						<span class="code">y</span>
						refer to <i>exactly</i> the same logger object.
					</p>
					<p>
						Thus, it is possible to configure a logger and then to retrieve the same 
						instance somewhere else in the code without passing around references. In 
						fundamental contradiction to biological parenthood, where parents always 
						precede their children, log4net loggers can be created and configured in any 
						order. In particular, a "parent" logger will find and link to its descendants 
						even if it is instantiated after them.
					</p>
					<p>
						Configuration of the log4net environment is typically done at application 
						initialization. The preferred way is by reading a configuration file. This 
						approach will be discussed shortly.
					</p>
					<p>
						Log4net makes it easy to name loggers by <i>software component</i>. This can be 
						accomplished by statically instantiating a logger in each class, with the 
						logger name equal to the fully qualified name of the class. This is a useful 
						and straightforward method of defining loggers. As the log output bears the 
						name of the generating logger, this naming strategy makes it easy to identify 
						the origin of a log message. However, this is only one possible, albeit common, 
						strategy for naming loggers. Log4net does not restrict the possible set of 
						loggers. The developer is free to name the loggers as desired.
					</p>
					<p>
						Nevertheless, naming loggers after the class where they are located seems to be 
						the best strategy known so far. It is simple an obvious to the developers where 
						each log message came from. Most importantly it leverages the design of the 
						application to produce the design of the logger hierarchy. Hopefully some 
						thought has gone into the design of the application.
					</p>
				</div>
				<h3><a id="loggers-and-appenders.appenders"></a>Appenders</h3>
				<div class="i1">
					<p>
						The ability to selectively enable or disable logging requests based on their 
						logger is only part of the picture. Log4net allows logging requests to print to 
						multiple destinations. In log4net speak, an output destination is called an <i>appender</i>.
						Appenders must implement the <span class="code">log4net.Appenders.IAppender</span>
						interface.
					</p>
					<p>
						The following appenders are defined in the log4net package:
					</p>
					<div class="table">
						<table cellspacing="0">
							<tr>
								<th>
									Type</th>
								<th>
									Description</th>
							</tr>
							<tr>
								<td>log4net.Appender.ADONetAppender</td>
								<td>
									Writes logging events to a database using either prepared statements or stored 
									procedures.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.ASPNetTraceAppender</td>
								<td>
									Writes logging events to the ASP trace context. These can then be rendered at 
									the end of the ASP page or on the ASP trace page.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.BufferingForwardingAppender</td>
								<td>
									Buffers logging events before forwarding them to child appenders.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.ColoredConsoleAppender</td>
								<td>
									Writes logging events to the application's Console. The events may go to either 
									the standard our stream or the standard error stream. The events may have configurable
									text and background colors defined for each level.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.ConsoleAppender</td>
								<td>
									Writes logging events to the application's Console. The events may go to either 
									the standard our stream or the standard error stream.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.EventLogAppender</td>
								<td>
									Writes logging events to the Windows Event Log.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.FileAppender</td>
								<td>
									Writes logging events to a file in the file system.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.ForwardingAppender</td>
								<td>
									Forwards logging events to child appenders.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.MemoryAppender</td>
								<td>
									Stores logging events in an in memory buffer.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.NetSendAppender</td>
								<td>
									Writes logging events to the Windows Messenger service. These messages are 
									displayed in a dialog on a users terminal.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.OutputDebugStringAppender</td>
								<td>
									Writes logging events to the debugger. If the application has no 
									debugger, the system debugger displays the string. If the application has no 
									debugger and the system debugger is not active, the message is ignored.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.RemotingAppender</td>
								<td>
									Writes logging events to a remoting sink using .NET remoting.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.RollingFileAppender</td>
								<td>
									Writes logging events to a file in the file system. The RollingFileAppender can 
									be configured to log to multiple files based upon date or file size 
									constraints.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.SMTPAppender</td>
								<td>
									Sends logging events to an email address.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.SmtpPickupDirAppender</td>
								<td>
									Writes SMTP messages as files into a pickup directory.
									These files can then be read and sent by an SMTP agent
									such as the IIS SMTP agent.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.TraceAppender</td>
								<td>
									Writes logging events to the .NET trace system.
								</td>
							</tr>
							<tr>
								<td>log4net.Appender.UdpAppender</td>
								<td>
									Sends logging events as connectionless UDP datagrams to a remote host or a 
									multicast group using a UdpClient.
								</td>
							</tr>
						</table>
					</div>
					<p>
						More than one appender can be attached to a logger.
					</p>
					<p>
						<strong>
							Each enabled logging request for a given logger will be forwarded to all 
							the appenders in that logger as well as the appenders higher in the hierarchy.
						</strong>
						In other words, appenders are inherited additively from the logger hierarchy. 
						For example, if a console appender is added to the <i>root</i> logger, then all 
						enabled logging requests will at least print on the console. If in addition a 
						file appender is added to a logger, say <i>X</i>, then enabled logging requests 
						for <i>X</i> and <i>X</i>'s children will print on a file <i>and</i> on the 
						console. It is possible to override this default behaviour so that appender 
						accumulation is no longer additive by setting the additivity flag on the logger 
						to
						<span class="code">false</span>.
					</p>
					<p>
						The rules governing appender additivity are summarized below.
					</p>
					<dl class="rule">
						<dt>Appender Additivity</dt>
						<dd>
							<p>
								The output of a log statement of logger <i>X</i> will go to all the appenders 
								in <i>X</i> and its ancestors. This is the meaning of the term "appender 
								additivity".
							</p>
							<p>
								However, if an ancestor of logger <i>X</i>, say <i>Y</i>, has the additivity 
								flag set to
								<span class="code">false</span>, then <i>X</i>'s output will be directed to all 
								the appenders in <i>X</i> and it's ancestors up to and including <i>Y</i> but 
								not the appenders in any of the ancestors of <i>Y</i>.
							</p>
							<p>
								Loggers have their additivity flag set to
								<span class="code">true</span>
								by default.
							</p>
						</dd>
					</dl>
					<p>
						The table below shows an example:
					</p>
					<div class="table">
						<table cellspacing="0">
							<tr>
								<th>
									Logger Name</th>
								<th>
									Added Appenders</th>
								<th>
									Additivity Flag</th>
								<th>
									Output Targets</th>
								<th>
									Comment</th>
							</tr>
							<tr>
								<td><i>root</i></td>
								<td>A1</td>
								<td>not applicable</td>
								<td>A1</td>
								<td>There is no default appender attached to <i>root</i>.</td>
							</tr>
							<tr>
								<td>x</td>
								<td>A-x1, A-x2</td>
								<td>true</td>
								<td>A1, A-x1, A-x2</td>
								<td>Appenders of "x" and <i>root</i>.</td>
							</tr>
							<tr>
								<td>x.y</td>
								<td>none</td>
								<td>true</td>
								<td>A1, A-x1, A-x2</td>
								<td>Appenders of "x" and <i>root</i>.</td>
							</tr>
							<tr>
								<td>x.y.z</td>
								<td>A-xyz1</td>
								<td>true</td>
								<td>A1, A-x1, A-x2, A-xyz1</td>
								<td>Appenders in "x.y.z", "x" and <i>root</i>.</td>
							</tr>
							<tr>
								<td>security</td>
								<td>A-sec</td>
								<td><span class="code">false</span></td>
								<td>A-sec</td>
								<td>No appender accumulation since the additivity flag is set to
									<span class="code">false</span>.</td>
							</tr>
							<tr>
								<td>security.access</td>
								<td>none</td>
								<td>true</td>
								<td>A-sec</td>
								<td>Only appenders of "security" because the additivity flag in "security" is set 
									to
									<span class="code">false</span>.</td>
							</tr>
						</table>
					</div>
				</div>
				<h3><a id="loggers-and-appenders.filters"></a>Filters</h3>
				<div class="i1">
					<p>
						Appenders can filter the events that are delivered to them. The filters can be 
						specified in the configuration to allow fine control of the events that are 
						logged through different appenders.
					</p>
					<p>
						The simplest form of control is to specify a
						<span class="code">Threshold</span>
						on the appender. This works by logging only the events that have a level that 
						is greater than or equal to the threshold.
					</p>
					<p>
						More complex and custom event filtering can be done using the filter chain 
						defined on each appender. Filters must implement the
						<span class="code">IFilter</span>.
					</p>
					<p>
						The following filters are defined in the log4net package:
					</p>
					<div class="table">
						<table cellspacing="0">
							<tr>
								<th>
									Type</th>
								<th>
									Description</th>
							</tr>
							<tr>
								<td>log4net.Filter.DenyAllFilter</td>
								<td>
									Drops all logging events.
								</td>
							</tr>
							<tr>
								<td>log4net.Filter.LevelMatchFilter</td>
								<td>
									An exact match to the event's level.
								</td>
							</tr>
							<tr>
								<td>log4net.Filter.MDCFilter</td>
								<td>
									Matches a substring from a specific <span class="code">MDC</span> value.
								</td>
							</tr>
							<tr>
								<td>log4net.Filter.NDCFilter</td>
								<td>
									Matches a substring from the event's <span class="code">NDC</span>.
								</td>
							</tr>
							<tr>
								<td>log4net.Filter.LevelRangeFilter</td>
								<td>
									Matches against a range of levels.
								</td>
							</tr>
							<tr>
								<td>log4net.Filter.StringMatchFilter</td>
								<td>
									Matches a substring from the event's message.
								</td>
							</tr>
						</table>
					</div>
					<p>
						The filters can be configured to either accept or reject the event based upon 
						the match.
					</p>
				</div>
				<h3><a id="loggers-and-appenders.layouts"></a>Layouts</h3>
				<div class="i1">
					<p>
						More often than not, users wish to customize not only the output destination 
						but also the output format. This is accomplished by associating a <i>layout</i> 
						with an appender. The layout is responsible for formatting the logging request 
						according to the user's wishes, whereas an appender takes care of sending the 
						formatted output to its destination. The
						<span class="code">PatternLayout</span>, part of the standard log4net 
						distribution, lets the user specify the output format according to conversion 
						patterns similar to the C language
						<span class="code">printf</span>
						function.
					</p>
					<p>
						For example, the PatternLayout with the conversion pattern
						<span class="code">"%r [%t] %-5p %c - %m%n"</span>
						will output something akin to:
					</p>
					<pre class="code">
176 [main] INFO  Com.Foo.Bar - Located nearest gas station.</pre>
					<p>
						The first field is the number of milliseconds elapsed since the start of the 
						program. The second field is the thread making the log request. The third field 
						is the level of the log statement. The fourth field is the name of the logger 
						associated with the log request. The text after the '-' is the message of the 
						statement.
					</p>
					<p>
						The following layouts are included in the log4net package:
					</p>
					<div class="table">
						<table cellspacing="0">
							<tr>
								<th>
									Type</th>
								<th>
									Description</th>
							</tr>
							<tr>
								<td>log4net.Layout.ExceptionLayout</td>
								<td>
									Renders the exception text from the logging 
									event.
								</td>
							</tr>
							<tr>
								<td>log4net.Layout.PatternLayout</td>
								<td>
									Formats the logging event according to a flexible 
									set of formatting flags.
								</td>
							</tr>
							<tr>
								<td>log4net.Layout.RawTimeStampLayout</td>
								<td>
									Extracts the timestamp from the logging event.
								</td>
							</tr>
							<tr>
								<td>log4net.Layout.SimpleLayout</td>
								<td>
									Formats the logging event very simply:
									<span class="code">[level] - [message]</span>
								</td>
							</tr>
							<tr>
								<td>log4net.Layout.XMLLayout</td>
								<td>
									Formats the logging event as an XML element.
								</td>
							</tr>
							<tr>
								<td>log4net.Layout.XMLLayoutSchemaLog4j</td>
								<td>
									Formats the logging event as an XML element that
									complies with the log4j event dtd.
								</td>
							</tr>
						</table>
					</div>
				</div>
				<h3><a id="loggers-and-appenders.or"></a>Object Renderers</h3>
				<div class="i1">
					<p>
						Just as importantly, log4net will render the content of the log message 
						according to user specified criteria. For example, if you frequently need to 
						log
						<span class="code">Oranges</span>, an object type used in your current project, 
						then you can register an
						<span class="code">OrangeRenderer</span>
						that will be invoked whenever an orange needs to be logged.
					</p>
					<p>
						Object rendering follows the class hierarchy. For example, assuming oranges are 
						fruits, if you register an
						<span class="code">FruitRenderer</span>, all fruits including oranges will be 
						rendered by the
						<span class="code">FruitRenderer</span>, unless of course you registered an 
						orange specific
						<span class="code">OrangeRenderer</span>.
					</p>
					<p>
						Object renderers have to implement the
						<span class="code">log4net.ObjectRenderer.IObjectRenderer</span>
						interface.
					</p>
				</div>
			</div>
			<h2><a id="configuration"></a>Configuration</h2>
			<div class="i1">
				<p>
					Inserting log requests into the application code requires a fair amount of 
					planning and effort. Observation shows that approximately 4 percent of code is 
					dedicated to logging. Consequently, even moderately sized applications will 
					have thousands of logging statements embedded within their code. Given their 
					number, it becomes imperative to manage these log statements without the need 
					to modify them manually.
				</p>
				<p>
					The log4net environment is fully configurable programmatically. However, it is 
					far more flexible to configure log4net using configuration files. Currently, 
					configuration files are written in XML.
				</p>
				<p>
					Let us give a taste of how this is done with the help of an imaginary 
					application
					<span class="code">MyApp</span>
					that uses log4net.
				</p>
				<pre class="code">
using Com.Foo;

// Import log4net classes.
<b>using log4net;
using log4net.Config;</b>

public class MyApp 
{
	// Define a static logger variable so that it references the
	// Logger instance named "MyApp".
	<strong>private static readonly</strong> ILog log = <strong>LogManager.GetLogger(typeof(MyApp));</strong>

	static void Main(string[] args) 
	{
		// Set up a simple configuration that logs on the console.
		<strong>BasicConfigurator.Configure();</strong>

		log.Info("Entering application.");
		Bar bar = new Bar();
		bar.DoIt();
		log.Info("Exiting application.");
	}
}
</pre>
				<p>
					<span class="code">MyApp</span>
					begins by importing log4net related classes. It then defines a static logger 
					variable with the name
					<span class="code">MyApp</span>
					which happens to be the fully qualified name of the class.
				</p>
				<p>
					<span class="code">MyApp</span>
					uses the following
					<span class="code">Bar</span>
					class:
				</p>
				<pre class="code">
// Import log4net classes.
using log4net;

<b>namespace Com.Foo</b>
{
	public class Bar 
	{
		<strong>private static readonly</strong> ILog log = <strong>LogManager.GetLogger(typeof(Bar));</strong>

		public void DoIt()
		{
			log.Debug("Did it again!");
		}
	}
}</pre>
				<p>
					The invocation of the
					<span class="code">BasicConfigurator.Configure()</span>
					method creates a rather simple log4net setup. This method is hardwired to add 
					to the <i>root</i> logger a
					<span class="code">ConsoleAppender</span>. The output will be formatted using a
					<span class="code">PatternLayout</span>
					set to the pattern
					<span class="code">"%-4r [%t] %-5p %c %x - %m%n"</span>.
				</p>
				<p>
					Note that by default, the <i>root</i> logger is assigned to
					<span class="code">Level.DEBUG</span>.
				</p>
				<p>
					The output of <span class="code">MyApp</span> is:
				</p>
				<pre class="code">
0    [main] INFO  MyApp  - Entering application.
36   [main] DEBUG Com.Foo.Bar  - Did it again!
51   [main] INFO  MyApp  - Exiting application.
</pre>
				<p>
					As a side note, let me mention that in log4net child loggers link only to their 
					existing ancestors. In particular, the logger named
					<span class="code">Com.Foo.Bar</span>
					is linked directly to the
					<i>root</i>
					logger, thereby circumventing the unused
					<span class="code">Com</span>
					or
					<span class="code">Com.Foo</span>
					loggers. This significantly increases performance and reduces log4net's memory 
					footprint.
				</p>
				<p>
					The
					<span class="code">MyApp</span>
					class configures log4net by invoking
					<span class="code">BasicConfigurator.Configure()</span>
					method. Other classes only need to import the
					<span class="code">log4net</span>
					namespace, retrieve the loggers they wish to use, and log away.
				</p>
				<p>
					The previous example always outputs the same log information. Fortunately, it 
					is easy to modify
					<span class="code">MyApp</span>
					so that the log output can be controlled at run-time. Here is a slightly 
					modified version.
				</p>
				<pre class="code">
using Com.Foo;

// Import log4net classes.
using log4net;
<b>using log4net.Config;</b>

public class MyApp 
{
	private static readonly ILog log = LogManager.GetLogger(typeof(MyApp));

	static void Main(string[] args) 
	{
		// BasicConfigurator replaced with DOMConfigurator.
		<strong>DOMConfigurator.Configure(new System.IO.FileInfo(args[0]));</strong>

		log.Info("Entering application.");
		Bar bar = new Bar();
		bar.DoIt();
		log.Info("Exiting application.");
	}
}
</pre>
				<p>
					This version of
					<span class="code">MyApp</span>
					instructs the 
					<span class="code">DOMConfigurator</span>
					to parse a configuration file and set up logging accordingly. The path to the 
					configuration file is specified on the command line.
				</p>
				<p>
					Here is a sample configuration file that results in exactly same output as the 
					previous
					<span class="code">BasicConfigurator</span>
					based example.
				</p>
				<pre class="code">
&lt;log4net&gt;
	&lt;!-- A1 is set to be a ConsoleAppender --&gt;
	&lt;appender name="A1" type="log4net.Appender.ConsoleAppender"&gt;

		&lt;!-- A1 uses PatternLayout --&gt;
		&lt;layout type="log4net.Layout.PatternLayout"&gt;
			&lt;conversionPattern value="%-4r [%t] %-5p %c %x - %m%n" /&gt;
		&lt;/layout&gt;
	&lt;/appender&gt;
	
	&lt;!-- Set root logger level to DEBUG and its only appender to A1 --&gt;
	&lt;root&gt;
		&lt;level value="DEBUG" /&gt;
		&lt;appender-ref ref="A1" /&gt;
	&lt;/root&gt;
&lt;/log4net&gt;
</pre>
				<p>
					Suppose we are no longer interested in seeing the output of any component 
					belonging to the
					<span class="code">Com.Foo</span>
					package. The following configuration file shows one possible way of achieving 
					this.
				</p>
				<pre class="code">
&lt;log4net&gt;
	&lt;!-- A1 is set to be a ConsoleAppender --&gt;
	&lt;appender name="A1" type="log4net.Appender.ConsoleAppender"&gt;

		&lt;!-- A1 uses PatternLayout --&gt;
		&lt;layout type="log4net.Layout.PatternLayout"&gt;
			&lt;!-- <strong>Print the date in ISO 8601 format</strong> --&gt;
			&lt;conversionPattern value="<strong>%d</strong> [%t] %-5p %c %x - %m%n" /&gt;
		&lt;/layout&gt;
	&lt;/appender&gt;
	
	&lt;!-- Set root logger level to DEBUG and its only appender to A1 --&gt;
	&lt;root&gt;
		&lt;level value="DEBUG" /&gt;
		&lt;appender-ref ref="A1" /&gt;
	&lt;/root&gt;
	
	&lt;!-- Print only messages of level WARN or above in the package Com.Foo --&gt;
	<strong>&lt;logger name="Com.Foo"&gt;
		&lt;level value="WARN" /&gt;
	&lt;/logger&gt;</strong>
&lt;/log4net&gt;
</pre>
				<p>
					The output of
					<span class="code">MyApp</span>
					configured with this file is shown below.
				</p>
				<pre class="code">
<strong>2000-09-07 14:07:41,508</strong> [main] INFO  MyApp - Entering application.
<strong>2000-09-07 14:07:41,529</strong> [main] INFO  MyApp - Exiting application.
</pre>
				<p>
					As the logger
					<span class="code">Com.Foo.Bar</span>
					does not have an assigned level, it inherits its level from
					<span class="code">Com.Foo</span>, which was set to WARN in the configuration 
					file. The log statement from the
					<span class="code">Bar.DoIt</span>
					method has the level DEBUG, lower than the logger level WARN. Consequently,
					<span class="code">DoIt()</span>
					method's log request is suppressed.
				</p>
				<p>
					Here is another configuration file that uses multiple appenders.
				</p>
				<pre class="code">
&lt;log4net&gt;
	&lt;appender name="Console" type="log4net.Appender.ConsoleAppender"&gt;
		&lt;layout type="log4net.Layout.PatternLayout"&gt;
			&lt;!-- Pattern to output the caller's file name and line number --&gt;
			&lt;conversionPattern value="%5p [%t] (%F:%L) - %m%n" /&gt;
		&lt;/layout&gt;
	&lt;/appender&gt;
	
	&lt;appender name="RollingFile" type="log4net.Appender.RollingFileAppender"&gt;
		&lt;file value="example.log" /&gt;
		&lt;appendToFile value="true" /&gt;
		&lt;maximumFileSize value="100KB" /&gt;
		&lt;maxSizeRollBackups value="2" /&gt;

		&lt;layout type="log4net.Layout.PatternLayout"&gt;
			&lt;conversionPattern value="%p %t %c - %m%n" /&gt;
		&lt;/layout&gt;
	&lt;/appender&gt;
	
	&lt;root&gt;
		&lt;level value="DEBUG" /&gt;
		&lt;appender-ref ref="Console" /&gt;
		&lt;appender-ref ref="RollingFile" /&gt;
	&lt;/root&gt;
&lt;/log4net&gt;
</pre>
				<p>
					Calling the enhanced <span class="code">MyApp</span> with the this configuration file will output the 
					following on the console.
				</p>
				<pre class="code">
 INFO [main] (MyApp.cs:16) - Entering application.
DEBUG [main] (Bar.cs:12) - Doing it again!
 INFO [main] (MyApp.cs:19) - Exiting application.
</pre>
				<p>
					In addition, as the <i>root</i> logger has been allocated a second appender, output 
					will also be directed to the
					<span class="code">example.log</span>
					file. This file will be rolled over when it reaches 100KB. When roll-over 
					occurs, the old version of
					<span class="code">example.log</span>
					is automatically moved to
					<span class="code">example.log.1</span>.
				</p>
				<p>
					Note that to obtain these different logging behaviours we did not need to 
					recompile code. We could just as easily have logged to an email address, 
					redirected all
					<span class="code">Com.Foo</span>
					output to an NT Event logger, or forwarded logging events to a remote log4net 
					server, which would log according to local server policy.
				</p>
				<p>
					For more examples of configuring appenders using the <span class="code">DOMConfigurator</span>
					see the <a href="example-config-appender.html">Example Appender Configuration</a> 
					document.
				</p>
				<h3><a id="configuration.attr"></a>Configuration Attributes</h3>
				<div class="i1">
					<p>
						The log4net configuration can be configured using assembly-level attributes rather than
						specified programmatically.
					</p>
					<ul>
						<li>
							<h4>DOMConfiguratorAttribute</h4>
							<p>
								The <span class="code">log4net.Config.DOMConfiguratorAttribute</span> Allows the
								<span class="code">DOMConfigurator</span> to be configured using the following properties:
							</p>
							<ul>
								<li>
									<h4>ConfigFile</h4>
									<p>
										If specified, this is the filename of the configuration file to use with the
										<span class="code">DOMConfigurator</span>. This file path is relative to the 
										application base directory (<span class="code">AppDomain.CurrentDomain.BaseDirectory</span>).
									</p>
									<p>
										This property cannot be used in conjunction with the 
										<span class="code">ConfigFileExtension</span> property.
									</p>
								</li>
								<li>
									<h4>ConfigFileExtension</h4>
									<p>
										If specified, this is the extension for the configuration file. The assembly 
										file name is used as the base name with the this extension appended. For example
										if the assembly is loaded from the a file <span class="code">TestApp.exe</span>
										and the <span class="code">ConfigFileExtension</span> property is set to
										<span class="code">log4net</span> then the configuration file name is 
										<span class="code">TestApp.exe.log4net</span>. This is equivalent to setting the
										<span class="code">ConfigFile</span> property to <span class="code">TestApp.exe.log4net</span>.
									</p>
									<p>
										The path to the configuration file is build by using the application base 
										directory (<span class="code">AppDomain.CurrentDomain.BaseDirectory</span>), 
										the assembly file name and the configuration file extension.
									</p>
									<p>
										This property cannot be used in conjunction with the 
										<span class="code">ConfigFile</span> property.
									</p>
								</li>
								<li>
									<h4>Watch</h4>
									<p>
										If this flag is specified and set to <span class="code">true</span>
										then the framework will watch the configuration file and will reload the config 
										each time the file is modified.
									</p>
								</li>
							</ul>
							<p>
								If neither of the <span class="code">ConfigFile</span> or <span class="code">ConfigFileExtension</span>
								properties are specified, the application configuration file (e.g. <span class="code">TestApp.exe.config</span>) 
								will be used as the log4net configuration file.
							</p>
							<p>
								Example usage:
							</p>
							<pre class="code">
// Configure log4net using the .config file
<b>[assembly: log4net.Config.DOMConfigurator(Watch=true)]</b>
// This will cause log4net to look for a configuration file
// called TestApp.exe.config in the application base
// directory (i.e. the directory containing TestApp.exe)
// The config file will be watched for changes.
							</pre>
							<pre class="code">
// Configure log4net using the .log4net file
<b>[assembly: log4net.Config.DOMConfigurator(ConfigFileExtension="log4net",Watch=true)]</b>
// This will cause log4net to look for a configuration file
// called TestApp.exe.log4net in the application base
// directory (i.e. the directory containing TestApp.exe)
// The config file will be watched for changes.
							</pre>
							<p>
								This attribute may only be used once per assembly.
							</p>
						</li>
					</ul>
					<p>
						Using attributes can be a clearer method for defining where the application's
						configuration will be loaded from. However it is worth noting that attributes
						are purely passive. They are information only. Therefore if you use configuration
						attributes you must invoke log4net to allow it to read the attributes. A simple
						call to <span class="code">LogManager.GetLogger</span> will cause the attributes
						on the calling assembly to be read and processed. <strong>Therefore it is imperative
						to make a logging call as early as possible during the application start-up, and
						certainly before any external assemblies have been loaded and invoked.</strong>
					</p>
				</div>
				<h3><a id="configuration.files"></a>Configuration Files</h3>
				<div class="i1">
					<p>
						Typically the log4net configuration is specified using a file. This file can
						be read in one of two ways:
					</p>
					<ul>
						<li>Using the .NET <span class="code">System.Configuration</span> API</li>
						<li>Reading the file contents directly</li>
					</ul>
					
					<h4><a id="configuration.files.config"></a>.config Files</h4>
					<div class="i1">
						<p>	
							The <span class="code">System.Configuration</span> API is only available if the
							configuration data is in the application's config file; the file named 
							<i>MyApp.exe.config</i> or <i>Web.config</i>. Because the <span class="code">System.Configuration</span> 
							API does not support reloading of the config file the configuration settings 
							cannot be watched using the <span class="code">log4net.Config.DOMConfigurator.ConfigureAndWatch</span> 
							methods. The main advantage of using the <span class="code">System.Configuration</span>
							APIs to read the configuration data is that it requires less permissions than accessing
							the configuration file directly.
						</p>
						<p>
							The only way to configure an application using the <span class="code">System.Configuration</span>
							APIs is to call the <span class="code">log4net.Config.DOMConfigurator.Configure()</span> method or
							the <span class="code">log4net.Config.DOMConfigurator.Configure(ILoggerRepository)</span> method.
						</p>
						<p>
							In order to embed the configuration data in the .config file the section name must be
							identified to the .NET config file parser using a <span class="code">configSections</span> element.
							The section must specify the <span class="code">log4net.Config.Log4NetConfigurationSectionHandler</span>
							that will be used to parse the config section. This type must be fully assembly qualified
							because it is being loaded by the .NET config file parser not by log4net. The correct
							assembly name for the log4net assembly must be specified.
							The following is a simple example configuration file that specifies the correct
							section handler to use for the log4net section.
						</p>
						<pre class="code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
	&lt;configSections&gt;
		&lt;section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler, log4net" /&gt;
	&lt;/configSections&gt;
	&lt;log4net&gt;
		&lt;appender name="ConsoleAppender" type="log4net.Appender.ConsoleAppender" &gt;
			&lt;layout type="log4net.Layout.PatternLayout"&gt;
				&lt;param name="ConversionPattern" value="%d [%t] %-5p %c [%x] - %m%n" /&gt;
			&lt;/layout&gt;
		&lt;/appender&gt;
		&lt;root&gt;
			&lt;level value="INFO" /&gt;
			&lt;appender-ref ref="ConsoleAppender" /&gt;
		&lt;/root&gt;
	&lt;/log4net&gt;
&lt;/configuration&gt;
						</pre>
						<p>
							In the above example the <span class="code">log4net</span> assembly is specified.
							This assembly must be located where the .NET runtime can find it. For example it could
							be located in the same directory as the application. If the log4net assembly is stored in
							the GAC then the fully qualified assembly name must be specified including the culture,
							version and public key.
						</p>
						<p>
							When using the .config file to specify the configuration the section name and 
							XML element name must be <span class="code">log4net</span>.
						</p>
					</div>
					<h4><a id="configuration.files.direct"></a>Reading Files Directly</h4>
					<div class="i1">
						<p>
							The DOMConfigurator can directly read any XML file and use it to configure log4net. 
							This includes the application's .config file; the file named <i>MyApp.exe.config</i> 
							or <i>Web.config</i>. The only reason not to read the configuration file directly is if the
							application does not have sufficient permissions to read the file, then the configuration
							must be loaded using the .NET configuration APIs (see above).
						</p>
						<p>
							The file to read the configuration from can be specified using any of
							the <span class="code">log4net.Config.DOMConfigurator</span> methods that
							accept a <span class="code">System.IO.FileInfo</span> object. Because the
							file system can be monitored for file change notifications the 
							<span class="code">ConfigureAndWatch</span> methods can be used to monitor
							the configuration file for modifications and automatically reconfigure log4net.
						</p>
						<p>
							Additionally the <span class="code">log4net.Config.DOMConfiguratorAttribute</span>
							can be used to specify the file to read the configuration from.
						</p>
						<p>
							The configuration is read from the <span class="code">log4net</span> element
							in the file. Only one <span class="code">log4net</span> element can be specified
							in the file but it may be located anywhere in the XML hierarchy. For example it
							may be the root element:
						</p>
						<pre class="code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;log4net&gt;
	&lt;appender name="ConsoleAppender" type="log4net.Appender.ConsoleAppender" &gt;
		&lt;layout type="log4net.Layout.PatternLayout"&gt;
			&lt;param name="ConversionPattern" value="%d [%t] %-5p %c [%x] - %m%n" /&gt;
		&lt;/layout&gt;
	&lt;/appender&gt;
	&lt;root&gt;
		&lt;level value="INFO" /&gt;
		&lt;appender-ref ref="ConsoleAppender" /&gt;
	&lt;/root&gt;
&lt;/log4net&gt;
						</pre>
						<p>
							Or it may be nested within other elements:
						</p>
						<pre class="code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
	&lt;configSections&gt;
		&lt;section name="log4net" type="System.Configuration.IgnoreSectionHandler" /&gt;
	&lt;/configSections&gt;
	&lt;log4net&gt;
		&lt;appender name="ConsoleAppender" type="log4net.Appender.ConsoleAppender" &gt;
			&lt;layout type="log4net.Layout.PatternLayout"&gt;
				&lt;param name="ConversionPattern" value="%d [%t] %-5p %c [%x] - %m%n" /&gt;
			&lt;/layout&gt;
		&lt;/appender&gt;
		&lt;root&gt;
			&lt;level value="INFO" /&gt;
			&lt;appender-ref ref="ConsoleAppender" /&gt;
		&lt;/root&gt;
	&lt;/log4net&gt;
&lt;/configuration&gt;
						</pre>
						<p>
							The above example shows how the configuration data can be embedded 
							inside a .config file even though the file is being read directly
							by log4net. An important note is that the .NET config file parser
							will throw an exception if it finds an element that has not been
							registered using the <span class="code">configSections</span> element.
							Therefore in the above example the <span class="code">log4net</span>
							section name is registered, but the type specified to handle the
							section is <span class="code">System.Configuration.IgnoreSectionHandler</span>.
							This is a built-in class that indicates that another method for reading
							the config section will be employed.
						</p>
					</div>
					
				</div>
				
				<h3><a id="configuration.syntax"></a>Configuration Syntax</h3>
				<div class="i1">
					<p>
						log4net includes a configuration reader that parses an XML DOM, the 
						<span class="code">log4net.Config.DOMConfigurator</span>. This section defines the
						syntax accepted by the configurator.
					</p>
					<p>
						This is an example of a valid XML configuration. The root element
						must be <span class="code">&lt;log4net&gt;</span>. Note that this does not mean
						that this element cannot be embedded in another XML document. See the section above 
						on <a href="#configuration.files">Configuration Files</a> for more information
						on how to embed the DOMConfigurator XML in a configuration file.
					</p>
					<pre class="code">
&lt;log4net&gt;
	&lt;appender name="ConsoleAppender" type="log4net.Appender.ConsoleAppender" &gt;
		&lt;layout type="log4net.Layout.PatternLayout"&gt;
			&lt;param name="ConversionPattern" value="%d [%t] %-5p %c [%x] - %m%n" /&gt;
		&lt;/layout&gt;
	&lt;/appender&gt;
	&lt;root&gt;
		&lt;level value="INFO" /&gt;
		&lt;appender-ref ref="ConsoleAppender" /&gt;
	&lt;/root&gt;
&lt;/log4net&gt;
					</pre>
					<p>
						The <span class="code">&lt;log4net&gt;</span> element supports the following attributes:
					</p>
					<div class="table">
						<table cellspacing="0">
							<colgroup>
								<col style="text-align: left; white-space: nowrap; width: 7em" />
								<col style="text-align: left;" />
							</colgroup>
							<tr>
								<th>Attribute</th>
								<th>Description</th>
							</tr>
							<tr>
								<td>debug</td>
								<td>
									Optional attribute. Value must be either <span class="code">true</span> or <span class="code">false</span>.
									The default value is <span class="code">false</span>. Set this attribute to <span class="code">true</span>
									to enable internal log4net debugging for this configuration.
								</td>
							</tr>
							<tr>
								<td>update</td>
								<td>
									Optional attribute. Value must be either <span class="code">Merge</span> or <span class="code">Overwrite</span>.
									The default value is <span class="code">Merge</span>. Set this attribute to <span class="code">Overwrite</span>
									to reset the configuration of the repository being configured before applying this configuration.
								</td>
							</tr>
							<tr>
								<td>threshold</td>
								<td>
									Optional attribute. Value must be the name of a level registered on the repository.
									The default value is <span class="code">ALL</span>. Set this attribute to limit the messages
									that are logged across the whole repository, regardless of the logger that the message is logged to.
								</td>
							</tr>
						</table>
					</div>
					<p>
						The <span class="code">&lt;log4net&gt;</span> element supports the following child elements:
					</p>
					<div class="table">
						<table cellspacing="0">
							<colgroup>
								<col style="text-align: left; white-space: nowrap; width: 7em" />
								<col style="text-align: left;" />
							</colgroup>
							<tr>
								<th>Element</th>
								<th>Description</th>
							</tr>
							<tr>
								<td>appender</td>
								<td>
									Zero or more elements allowed. Defines an appender.
								</td>
							</tr>
							<tr>
								<td>logger</td>
								<td>
									Zero or more elements allowed. Defines the configuration of a logger.
								</td>
							</tr>
							<tr>
								<td>renderer</td>
								<td>
									Zero or more elements allowed. Defines an object renderer.
								</td>
							</tr>
							<tr>
								<td>root</td>
								<td>
									Optional element, maximum of one allowed. Defines the configuration of the root logger.
								</td>
							</tr>
							<tr>
								<td>param</td>
								<td>
									Zero or more elements allowed. Repository specific parameters
								</td>
							</tr>
						</table>
					</div>
					
					<h4><a id="configuration.syntax.appender"></a>Appenders</h4>
					<div class="i1">
						<p>
							Appenders may only be defined as child elements of the <span class="code">&lt;log4net&gt;</span>
							element. Each appender must be uniquely named. The implementing type for the appender must be specified.
						</p>
						<p>
							This example shows an appender of type <span class="code">log4net.Appender.ConsoleAppender</span> being
							defined. The appender will be known as <i>ConsoleAppender</i>.
						</p>
						<pre class="code">
&lt;appender name="ConsoleAppender" type="log4net.Appender.ConsoleAppender" &gt;
	&lt;layout type="log4net.Layout.PatternLayout"&gt;
		&lt;param name="ConversionPattern" value="%d [%t] %-5p %c [%x] - %m%n" /&gt;
	&lt;/layout&gt;
&lt;/appender&gt;
						</pre>
						
						<p>
							The <span class="code">&lt;appender&gt;</span> element supports the following attributes:
						</p>
						<div class="table">
							<table cellspacing="0">
								<colgroup>
									<col style="text-align: left; white-space: nowrap; width: 7em" />
									<col style="text-align: left;" />
								</colgroup>
								<tr>
									<th>Attribute</th>
									<th>Description</th>
								</tr>
								<tr>
									<td>name</td>
									<td>
										Required attribute. Value must be a string name for this appender. The name must be unique
										among all the appenders defined in this configuration file. This name is used by the 
										<span class="code">&lt;appender-ref&gt;</span> element of a Logger to reference an appender.
									</td>
								</tr>
								<tr>
									<td>type</td>
									<td>
										Required attribute. Value must be the type name for this appender. If the appender is
										not defined in the log4net assembly this type name must be fully assembly qualified.
									</td>
								</tr>
							</table>
						</div>
						<p>
							The <span class="code">&lt;appender&gt;</span> element supports the following child elements:
						</p>
						<div class="table">
							<table cellspacing="0">
								<colgroup>
									<col style="text-align: left; white-space: nowrap; width: 7em" />
									<col style="text-align: left;" />
								</colgroup>
								<tr>
									<th>Element</th>
									<th>Description</th>
								</tr>
								<tr>
									<td>appender-ref</td>
									<td>
										Zero or more elements allowed. Allows the appender to reference other appenders.
										Not supported by all appenders.
									</td>
								</tr>
								<tr>
									<td>filter</td>
									<td>
										Zero or more elements allowed. Defines the filters used by this appender.
									</td>
								</tr>
								<tr>
									<td>layout</td>
									<td>
										Optional element, maximum of one allowed. Defines the layout used by this appender.
									</td>
								</tr>
								<tr>
									<td>param</td>
									<td>
										Zero or more elements allowed. Appender specific parameters.
									</td>
								</tr>
							</table>
						</div>
						
						<p>
							For examples of configuring appenders see the 
							<a href="example-config-appender.html">Example Appender Configuration</a> 
							document.
						</p>
												
						<h5><a id="configuration.syntax.appender.filter"></a>Filters</h5>
						<div class="i1">
							<p>
								Filters elements may only be defined as children of <span class="code">&lt;appender&gt;</span> elements.
							</p>
							<p>
								The <span class="code">&lt;filter&gt;</span> element supports the following attributes:
							</p>
							<div class="table">
								<table cellspacing="0">
									<colgroup>
										<col style="text-align: left; white-space: nowrap; width: 7em" />
										<col style="text-align: left;" />
									</colgroup>
									<tr>
										<th>Attribute</th>
										<th>Description</th>
									</tr>
									<tr>
										<td>type</td>
										<td>
											Required attribute. Value must be the type name for this filter. If the filter is
											not defined in the log4net assembly this type name must be fully assembly qualified.
										</td>
									</tr>
								</table>
							</div>
							<p>
								The <span class="code">&lt;filter&gt;</span> element supports the following child elements:
							</p>
							<div class="table">
								<table cellspacing="0">
									<colgroup>
										<col style="text-align: left; white-space: nowrap; width: 7em" />
										<col style="text-align: left;" />
									</colgroup>
									<tr>
										<th>Element</th>
										<th>Description</th>
									</tr>
									<tr>
										<td>param</td>
										<td>
											Zero or more elements allowed. Filter specific parameters.
										</td>
									</tr>
								</table>
							</div>							

							<p>
								Filters form a chain that the event has to pass through. Any filter along the way can accept the event 
								and stop processing, deny the event and stop processing, or allow the event on to the next filter. 
								If the event gets to the end of the filter chain without being denied it is implicitly accepted and will be logged.
							</p>
							<pre class="code">
&lt;filter type="log4net.Filter.LevelRangeFilter"&gt;
	&lt;param name="LevelMin" value="INFO" /&gt;
	&lt;param name="LevelMax" value="FATAL" /&gt;
&lt;/filter&gt;
							</pre>
							<p>
								This filter will deny events that have a level that is lower than <span class="code">INFO</span>
								or higher than <span class="code">FATAL</span>. 
								All events between <span class="code">INFO</span> and <span class="code">FATAL</span> will be logged.
							</p>
							<p>
								If we want to only allow messages through that have a specific substring (e.g. 'database') 
								then we need to specify the following filters:
							</p>
							<pre class="code">
&lt;filter type="log4net.Filter.StringMatchFilter"&gt;
	&lt;param name="StringToMatch" value="database" /&gt;
&lt;/filter&gt;
&lt;filter type="log4net.Filter.DenyAllFilter" /&gt;
							</pre>
							<p>
								The first filter will look for the substring 'database' in the message text of the event. 
								If the text is found the filter will accept the message and filter processing will stop, 
								the message will be logged. If the substring is not found the event will be passed to 
								the next filter to process. If there is no next filter the event would be implicitly 
								accepted and would be logged. But because we don't want the non matching events to be 
								logged we need to use a <span class="code">log4net.Filter.DenyAllFilter</span>
								that will just deny all events that reach it. This filter is only useful at the end of the filter chain.
							</p>
							<p>
								If we want to allow events that have either 'database' or 'ldap' in the message text we can use the following filters:
							</p>
							<pre class="code">
&lt;filter type="log4net.Filter.StringMatchFilter"&gt;
	&lt;param name="StringToMatch" value="database"/&gt;
&lt;/filter&gt;
&lt;filter type="log4net.Filter.StringMatchFilter"&gt;
	&lt;param name="StringToMatch" value="ldap"/&gt;
&lt;/filter&gt;
&lt;filter type="log4net.Filter.DenyAllFilter" /&gt;
							</pre>
						</div>
						
						<h5><a id="configuration.syntax.appender.layout"></a>Layouts</h5>
						<div class="i1">
							<p>
								Layout elements may only be defined as children of <span class="code">&lt;appender&gt;</span> elements.
							</p>
							<p>
								The <span class="code">&lt;layout&gt;</span> element supports the following attributes:
							</p>
							<div class="table">
								<table cellspacing="0">
									<colgroup>
										<col style="text-align: left; white-space: nowrap; width: 7em" />
										<col style="text-align: left;" />
									</colgroup>
									<tr>
										<th>Attribute</th>
										<th>Description</th>
									</tr>
									<tr>
										<td>type</td>
										<td>
											Required attribute. Value must be the type name for this layout. If the layout is
											not defined in the log4net assembly this type name must be fully assembly qualified.
										</td>
									</tr>
								</table>
							</div>
							<p>
								The <span class="code">&lt;layout&gt;</span> element supports the following child elements:
							</p>
							<div class="table">
								<table cellspacing="0">
									<colgroup>
										<col style="text-align: left; white-space: nowrap; width: 7em" />
										<col style="text-align: left;" />
									</colgroup>
									<tr>
										<th>Element</th>
										<th>Description</th>
									</tr>
									<tr>
										<td>param</td>
										<td>
											Zero or more elements allowed. Layout specific parameters.
										</td>
									</tr>
								</table>
							</div>
							<p>
								This example shows how to configure a layout that uses the <span class="code">log4net.Layout.PatternLayout</span>.
							</p>
							<pre class="code">
&lt;layout type="log4net.Layout.PatternLayout"&gt;
	&lt;param name="ConversionPattern" value="%d [%t] %-5p %c [%x] - %m%n" /&gt;
&lt;/layout&gt;
							</pre>
							
						</div>
						
						
					</div>
					
					<h4><a id="configuration.syntax.root"></a>Root Logger</h4>
					<div class="i1">
						<p>
							Only one root logger element may only be defined and it must be a child of <span class="code">&lt;log4net&gt;</span> element.
							The root logger is the root of the logger hierarchy. All logger ultimately inherit from this logger.
						</p>
						<p>
							An example root logger:
						</p>
						<pre class="code">
&lt;root&gt;
	&lt;level value="INFO" /&gt;
	&lt;appender-ref ref="ConsoleAppender" /&gt;
&lt;/root&gt;
						</pre>
						
						<p>
							The <span class="code">&lt;root&gt;</span> element supports no attributes.
						</p>
						<p>
							The <span class="code">&lt;root&gt;</span> element supports the following child elements:
						</p>
						<div class="table">
							<table cellspacing="0">
								<colgroup>
									<col style="text-align: left; white-space: nowrap; width: 7em" />
									<col style="text-align: left;" />
								</colgroup>
								<tr>
									<th>Element</th>
									<th>Description</th>
								</tr>
								<tr>
									<td>appender-ref</td>
									<td>
										Zero or more elements allowed. Allows the logger to reference appenders by name.
									</td>
								</tr>
								<tr>
									<td>level</td>
									<td>
										Optional element, maximum of one allowed. Defines the logging level for this logger.
										This logger will only accept event that are at this level or above.
									</td>
								</tr>
								<tr>
									<td>param</td>
									<td>
										Zero or more elements allowed. Logger specific parameters.
									</td>
								</tr>
							</table>
						</div>
					</div>
					
					<h4><a id="configuration.syntax.logger"></a>Loggers</h4>
					<div class="i1">
						<p>
							Logger elements may only be defined as children of the <span class="code">&lt;log4net&gt;</span> element.
						</p>
						<p>
							An example logger:
						</p>
						<pre class="code">
&lt;logger name="LoggerName"&gt;
	&lt;level value="DEBUG" /&gt;
	&lt;appender-ref ref="ConsoleAppender" /&gt;
&lt;/logger&gt;
						</pre>
						
						<p>
							The <span class="code">&lt;logger&gt;</span> element supports the following attributes.
						</p>
						<div class="table">
							<table cellspacing="0">
								<colgroup>
									<col style="text-align: left; white-space: nowrap; width: 7em" />
									<col style="text-align: left;" />
								</colgroup>
								<tr>
									<th>Attribute</th>
									<th>Description</th>
								</tr>
								<tr>
									<td>name</td>
									<td>
										Required attribute. Value must be the name of the logger.
									</td>
								</tr>
								<tr>
									<td>additivity</td>
									<td>
										Required attribute. Value must be either <span class="code">true</span> or <span class="code">false</span>.
										The default value is <span class="code">true</span>. Set this attribute to <span class="code">false</span>
										to prevent this logger from inheriting the appenders defined on parent loggers.
									</td>
								</tr>
							</table>
						</div>
						<p>
							The <span class="code">&lt;logger&gt;</span> element supports the following child elements:
						</p>
						<div class="table">
							<table cellspacing="0">
								<colgroup>
									<col style="text-align: left; white-space: nowrap; width: 7em" />
									<col style="text-align: left;" />
								</colgroup>
								<tr>
									<th>Element</th>
									<th>Description</th>
								</tr>
								<tr>
									<td>appender-ref</td>
									<td>
										Zero or more elements allowed. Allows the logger to reference appenders by name.
									</td>
								</tr>
								<tr>
									<td>level</td>
									<td>
										Optional element, maximum of one allowed. Defines the logging level for this logger.
										This logger will only accept event that are at this level or above.
									</td>
								</tr>
								<tr>
									<td>param</td>
									<td>
										Zero or more elements allowed. Logger specific parameters.
									</td>
								</tr>
							</table>
						</div>
					</div>
					
					<h4><a id="configuration.syntax.renderer"></a>Renderers</h4>
					<div class="i1">
						<p>
							Renderer elements may only be defined as children of the <span class="code">&lt;log4net&gt;</span> element.
						</p>
						<p>
							An example renderer:
						</p>
						<pre class="code">
&lt;renderer renderingClass="MyClass.MyRenderer" renderedClass="MyClass.MyFunkyObject" /&gt;
						</pre>
						
						<p>
							The <span class="code">&lt;renderer&gt;</span> element supports the following attributes.
						</p>
						<div class="table">
							<table cellspacing="0">
								<colgroup>
									<col style="text-align: left; white-space: nowrap; width: 7em" />
									<col style="text-align: left;" />
								</colgroup>
								<tr>
									<th>Attribute</th>
									<th>Description</th>
								</tr>
								<tr>
									<td>renderingClass</td>
									<td>
										Required attribute. Value must be the type name for this renderer. If the type is
										not defined in the log4net assembly this type name must be fully assembly qualified.
										This is the type of the object that will take responsibility for rendering the
										<i>renderedClass</i>.
									</td>
								</tr>
								<tr>
									<td>renderedClass</td>
									<td>
										Required attribute. Value must be the type name for the target type for this renderer. If the type is
										not defined in the log4net assembly this type name must be fully assembly qualified.
										This is the name of the type that this renderer will render.
									</td>
								</tr>
							</table>
						</div>
						<p>
							The <span class="code">&lt;renderer&gt;</span> element supports no child elements.
						</p>
					</div>
					
					<h4><a id="configuration.syntax.param"></a>Parameters</h4>
					<div class="i1">
						<p>
							Parameter elements may be children of many elements. See the specific elements above for details.
						</p>
						<p>
							An example param:
						</p>
						<pre class="code">
&lt;param name="ConversionPattern" value="%d [%t] %-5p %c [%x] - %m%n" /&gt;
						</pre>
						
						<p>
							The <span class="code">&lt;param&gt;</span> element supports the following attributes.
						</p>
						<div class="table">
							<table cellspacing="0">
								<colgroup>
									<col style="text-align: left; white-space: nowrap; width: 7em" />
									<col style="text-align: left;" />
								</colgroup>
								<tr>
									<th>Attribute</th>
									<th>Description</th>
								</tr>
								<tr>
									<td>name</td>
									<td>
										Required attribute. Value must be the name of the parameter to set on the parent object.
									</td>
								</tr>
								<tr>
									<td>value</td>
									<td>
										Optional attribute. One of <i>value</i> or <i>type</i> attributes must be specified.
										The value of this attribute is a string that can be converted to the value of the
										parameter.
									</td>
								</tr>
								<tr>
									<td>type</td>
									<td>
										Optional attribute. One of <i>value</i> or <i>type</i> attributes must be specified.
										The value of this attribute is a type name to create and set as the value of the
										parameter. If the type is not defined in the log4net assembly this type name must 
										be fully assembly qualified.
									</td>
								</tr>
							</table>
						</div>
						<p>
							The <span class="code">&lt;param&gt;</span> element supports the following child elements:
						</p>
						<div class="table">
							<table cellspacing="0">
								<colgroup>
									<col style="text-align: left; white-space: nowrap; width: 7em" />
									<col style="text-align: left;" />
								</colgroup>
								<tr>
									<th>Element</th>
									<th>Description</th>
								</tr>
								<tr>
									<td>param</td>
									<td>
										Zero or more elements allowed. Parameter specific parameters.
									</td>
								</tr>
							</table>
						</div>
						<p>
							An example param that uses nested param elements:
						</p>
						<pre class="code">
&lt;param name="evaluator" type="log4net.spi.LevelEvaluator"&gt;
	&lt;param name="Threshold" value="WARN"/&gt;
&lt;param&gt;
						</pre>
					
						<h5><a id="configuration.syntax.param.compact"></a>Compact Parameter Syntax</h5>
						<div class="i1">
							<p>
								Parameters may also be specified using the parameter name as the element name
								rather than using the <i>param</i> element and <i>name</i> attribute.
							</p>
							<p>
								For example a param:
							</p>
							<pre class="code">
&lt;param name="evaluator" type="log4net.spi.LevelEvaluator"&gt;
	&lt;param name="Threshold" value="WARN"/&gt;
&lt;param&gt;
							</pre>
							<p>
								may be written as:
							</p>
							<pre class="code">
&lt;evaluator type="log4net.spi.LevelEvaluator"&gt;
	&lt;threshold value="WARN"/&gt;
&lt;evaluator&gt;
							</pre>
						</div>
					</div>
				</div>
				
			</div>
			<h2><a id="ndc"></a>Nested Diagnostic Contexts</h2>
			<div class="i1">
				<p>
					Most real-world systems have to deal with multiple clients simultaneously. In a 
					typical multithreaded implementation of such a system, different threads will 
					handle different clients. Logging is especially well suited to trace and debug 
					complex distributed applications. A common approach to differentiate the 
					logging output of one client from another is to instantiate a new separate 
					logger for each client. This promotes the proliferation of loggers and 
					increases the management overhead of logging.
				</p>
				<p>
					A lighter technique is to uniquely stamp each log request initiated from the 
					same client interaction.
				</p>
				<p>
					To uniquely stamp each request, the user pushes contextual information into the
					<span class="code">NDC</span>, the abbreviation of <i>Nested Diagnostic Context</i>. 
					The
					<span class="code">NDC</span>
					class is shown below.
				</p>
				<div class="syntax">
					<pre class="code">
namespace log4net
{
	public class NDC
	{
		/// Removes the top context from the stack.
		public static string Pop();

		/// Pushes a new context message.
		public static IDisposable Push(string message);

		/// Gets the current context information.
		internal static string Get();
	}
}</pre>
				</div>
				<p>
					The <span class="code">NDC</span> is managed per thread as a <i>stack</i> of contextual information. Note 
					that all methods of the
					<span class="code">log4net.NDC</span>
					class are static. Assuming that <span class="code">NDC</span> printing is turned on, every time a log 
					request is made, the appropriate log4net component will include the <i>entire</i>
					<span class="code">NDC</span> stack for the current thread in the log output. This is done without the 
					intervention of the user, who is responsible only for placing the correct 
					information in the <span class="code">NDC</span> by using the
					<span class="code">Push</span>
					and
					<span class="code">Pop</span>
					methods at a few well-defined points in the code. In contrast, the per-client 
					logger approach commands extensive changes in the code.
				</p>
				<p>
					The
					<span class="code">NDC.Push</span>
					method returns an
					<span class="code">IDisposable</span>
					object that can be used to clean up the <span class="code">NDC</span> stack. This means that the user 
					does not have to manually match up a
					<span class="code">Pop</span>
					call for each
					<span class="code">Push</span>
					call. The
					<span class="code">using</span>
					syntax can be used to modify the <span class="code">NDC</span> only for a specific block of code. For 
					example:
				</p>
				<pre class="code">
NDC.Push("context");
log.Info("Message");
NDC.Pop();
</pre>
				<p>
					Is equivalent to:
				</p>
				<pre class="code">
using(NDC.Push("context"))
{
	log.Info("Message");
}
</pre>
				<p>
					The
					<span class="code">using</span>
					syntax is recommended because it removes some work load from the developer and 
					reduces errors in matching up the Push and Pop calls, especially when exceptions
					can occur.
				</p>
				<p>
					To illustrate this point, let us take the example of a web service delivering 
					content to numerous clients. The web service can build the <span class="code">NDC</span> at the very 
					beginning of the request before executing other code. The contextual 
					information can be the client's host name and other information inherent to the 
					request, typically information contained in cookies. Hence, even if the web 
					service is serving multiple clients simultaneously, the logs initiated by the 
					same code, i.e. belonging to the same logger, can still be distinguished 
					because each client request will have a different <span class="code">NDC</span> stack. Contrast this with 
					the complexity of passing a freshly instantiated logger to all code exercised 
					during the client's request.
				</p>
				<p>
					Nevertheless, some sophisticated applications, such as virtual hosting web 
					servers, must log differently depending on the virtual host context and also 
					depending on the software component issuing the request. Log4net supports 
					multiple hierarchy trees. This allows each virtual host to possess its own copy 
					of the logger hierarchy. Configuring multiple logger hierarchies is beyond the 
					scope of this document.
				</p>
			</div>
			<h2><a id="mdc"></a>Mapped Diagnostic Contexts</h2>
			<div class="i1">
				<p>
					The <span class="code">MDC</span> (Mapped Diagnostic Context) is used to set thread specific named 
					properties. These properties can be rendered by the
					<span class="code">PatternLayout</span>.
				</p>
				<p>
					The
					<span class="code">MDC</span>
					class is shown below.
				</p>
				<div class="syntax">
					<pre class="code">
namespace log4net
{
	public class MDC
	{
		/// Gets the context identified by the key parameter.
		public static string Get(string key);

		/// Puts a context value (the val parameter) as identified with 
		/// the key parameter into the current thread's context map.
		public static void Set(string key, string value);

		/// Removes the key value mapping for the key specified.
		public static void Remove(string key);
	}
}</pre>
				</div>
			</div>
			<h2><a id="plugins"></a>Plugins</h2>
			<div class="i1">
				<p>
					Plugins are additional modular components that are attached to a logger repository.
				</p>
				<p>
					Plugins are stored in the <span class="code">PluginMap</span> of an
					<span class="code">ILoggerRepository</span>. 
					Plugins are attached to the repository by using the <span class="code">PluginMap.Add</span>
					method.
				</p>
				<p>
					The following plugins are included in the log4net package:
				</p>
				<div class="table">
					<table cellspacing="0">
						<tr>
							<th>
								Type</th>
							<th>
								Description</th>
						</tr>
						<tr>
							<td>log4net.Plugin.RemoteLoggingServerPlugin</td>
							<td>
								Creates a remote logging sink that can receive logging events from a 
								<span class="code">RemotingAppender</span>.
							</td>
						</tr>
					</table>
				</div>
				<ul>
					<li>
						<h3>RemoteLoggingServerPlugin</h3>
						<p>
							Creates a remote logging sink that can receive logging events from a 
							<span class="code">RemotingAppender</span>.
						</p>
						<p>
							Creates a remoting logging sink. A single
							parameter must be passed to the constructor that specifies the sink URI. This is a
							name used to identify the logging sink object published via remoting and must be
							agreed with the client before communication can take place.
						</p>
						<p>
							Example usage:
						</p>
						<pre class="code">
LogManager.GetLoggerRepository().PluginMap.Add(new RemoteLoggingServerPlugin("LoggingSink"));
						</pre>
					</li>
				</ul>
				<h3>Plugin Attributes</h3>
				<div class="i1">
					<p>
						Plugins can be configured using the following assembly-level attributes:
					</p>
					<ul>
						<li>
							<h3>PluginAttribute</h3>
							<p>
								Specifies a plugin type to create and attach to the default repository. This attribute 
								does not allow plugins to be parameterised. The plugin class must have a public default constructor.
							</p>
							<p>
								This attribute may be used as many times as necessary to attach plugins to the repository.
							</p>
						</li>
					</ul>
				</div>
			</div>
			<h2><a id="performance"></a>Performance</h2>
			<div class="i1">
				<p>
					One of the often-cited arguments against logging is its computational cost. 
					This is a legitimate concern as even moderately sized applications can generate 
					thousands of log requests. Much effort was spent measuring and tweaking logging 
					performance. Log4net claims to be fast and flexible: speed first, flexibility 
					second.
				</p>
				<p>
					The user should be aware of the following performance issues.
				</p>
				<ol>
					<li>
						<strong>Logging performance when logging is turned off.</strong>
						<p>
							When logging is turned off entirely or just for a set of levels, the cost of a 
							log request consists of a method invocation plus an integer comparison.
						</p>
						<p>
							However, The method invocation involves the "hidden" cost of parameter 
							construction.
						</p>
						<p>
							For example, for some logger
							<span class="code">log</span>, writing,
						</p>
						<pre class="code">
log.Debug("Entry number: " + i + " is " + entry[i].ToString());</pre>
						<p>
							incurs the cost of constructing the message parameter, i.e. converting both 
							integer
							<span class="code">i</span>
							and
							<span class="code">entry[i]</span>
							to strings, and concatenating intermediate strings, regardless of whether the 
							message will be logged or not. This cost of parameter construction can be quite 
							high and it depends on the number and type of the parameters involved.
						</p>
						<p>
							To avoid the parameter construction cost write:
						</p>
						<pre class="code">
if(log.IsDebugEnabled)
{
	log.Debug("Entry number: " + i + " is " + entry[i].ToString());
}</pre>
						<p>
							This will not incur the cost of parameter construction if debugging is 
							disabled. On the other hand, if the logger is debug-enabled, it will incur 
							twice the cost of evaluating whether the logger is enabled or not: once in
							<span class="code">IsDebugEnabled</span>
							and once in
							<span class="code">Debug</span>. This is an insignificant overhead because 
							evaluating a logger takes about 1% of the time it takes to actually log.
						</p>
						<p>
							Certain users resort to pre-processing or compile-time techniques to compile 
							out all log statements. This leads to perfect performance efficiency with 
							respect to logging. However, since the resulting application binary does not 
							contain any log statements, logging cannot be turned on for that binary. In 
							many people's opinion this is a disproportionate price to pay in exchange for a 
							small performance gain.
						</p>
					</li>
					<li>
						<strong>The performance of deciding whether to log or not to log when logging is 
							turned on.</strong>
						<p>
							This is essentially the performance of walking the logger hierarchy. When 
							logging is turned on, log4net still needs to compare the level of the log 
							request with the level of the request logger. However, loggers may not have an 
							assigned level; they can inherit them from the logger hierarchy. Thus, before 
							inheriting a level, the logger may need to search its ancestors.
						</p>
						<p>
							There has been a serious effort to make this hierarchy walk to be as fast as 
							possible. For example, child loggers link only to their existing ancestors. In 
							the
							<span class="code">BasicConfigurator</span>
							example shown earlier, the logger named
							<span class="code">Com.Foo.Bar</span>
							is linked directly to the <i>root</i> logger, thereby circumventing the nonexistent
							<span class="code">Com</span>
							or
							<span class="code">Com.Foo</span>
							loggers. This significantly improves the speed of the walk, especially in 
							"sparse" hierarchies.
						</p>
						<p>
							The typical cost of walking the hierarchy is typically 3 times slower than when 
							logging is turned off entirely.
						</p>
					</li>
					<li>
						<strong>Actually outputting log messages</strong>
						<p>
							This is the cost of formatting the log output and sending it to its target 
							destination. Here again, a serious effort was made to make layouts (formatters) 
							perform as quickly as possible. The same is true for appenders.
						</p>
					</li>
				</ol>
				<p>
					Although log4net has many features, its first design goal was speed. Some 
					log4net components have been rewritten many times to improve performance. 
					Nevertheless, contributors frequently come up with new optimizations. You 
					should be pleased to know that when configured with the
					<span class="code">SimpleLayout</span>
					performance tests have shown log4net to log within an order of magnitude of
					<span class="code">System.Console.WriteLine</span>.
				</p>
			</div>
			<h2><a id="domains"></a>Logging Domains</h2>
			<div class="i1">
				<h3>Domain Attributes</h3>
				<div class="i1">
					<p>
						Logging domains are considered advanced functionality. The default behaviour
						should be sufficient for most users.
					</p>
					<p>
						Log4net supports logging domains. A domain is uniquely named. 
						Each domain links to a single repository (<span class="code">ILoggerRepository</span>).
						Multiple domains can link to the same repository.
					</p>
					<p>
						By default there is a single logging domain per process (or AppDomain). This extends
						across all assemblies loaded into the process and allows them to all share a
						single configuration. The configuration of the domain's repository only needs to be done once,
						typically in the entry point to the application, either programmatically or using 
						a configuration attribute.
					</p>
					<p>
						Named logging domains can be created using the <span class="code">LogManager.CreateDomain</span>
						method. The repository for a domain can be retrieved using the 
						<span class="code">LogManager.GetLoggerRepository</span> method.
						A repository created in this way will need to be configured programmatically.
					</p>
					<p>
						An assembly may choose to utilise a named logging domain rather than the default domain.
						This completely separates the logging for the assembly from the rest of the application.
						This can be very useful to component developers that wish to use log4net for their
						components but do not want to require that all the applications that use their
						component are aware of log4net. It also means that their debugging configuration is
						separated from the applications configuration. The assembly should specify the
						<span class="code">DomainAttribute</span> to set its logging domain name.
					</p>
					<p>
						The log4net logging domains can be configured using the following assembly-level 
						attributes:
					</p>
					<ul>
						<li>
							<h3>AliasDomainAttribute</h3>
							<p>
								Specifies a domain to alias to this assembly's repository.
							</p>
							<p>
								An assembly's logger repository is defined by its
								<span class="code">DomainAttribute</span>, however this can be overridden by an 
								assembly loaded before the target assembly.
							</p>
							<p>
								An assembly can alias another assembly's domain to its repository by specifying 
								this attribute with the name of the target domain.
							</p>
							<p>
								This attribute may be used as many times as necessary to alias all the required 
								domains.
							</p>
						</li>
						<li>
							<h3>DomainAttribute</h3>
							<p>
								Specifies the logging domain for the assembly.
							</p>
							<p>
								Assemblies are mapped to logging domains. Each domain has its own logging 
								repository. This attribute controls the configuration of the domain. The
								<span class="code">Name</span> property specifies the name of the domain 
								for this assembly. The <span class="code">RepositoryType</span>
								property specifies the type of the repository object to create for the domain. 
								If this attribute is not specified and a <span class="code">Name</span>
								is not specified then the assembly will be part of the default shared logging 
								domain.
							</p>
							<p>
								This attribute may only be used once per assembly.
							</p>
						</li>
					</ul>
				</div>
			</div>
			<h2><a id="logging-flow"></a>Logging Event Flow</h2>
			<div class="i1">
				<p>
					The following is the series of steps and checks that a messages goes through while being logged.
					For the purposes of this example we will document an <span class="code">INFO</span> level
					message being logged on logger <i>ConsoleApp.LoggingExample</i>. This logger is configured
					to use the <span class="code">log4net.Appender.ConsoleAppender</span>. The repository used
					in this example is a <span class="code">log4net.Repository.Hierarchy</span> object.
				</p>
				<ol>
					<li>
						<p>
							The user logs a message using the <span class="code">ILog.Info</span> method on the logger
							obtained using a call to <span class="code">log4net.LogManager.GetLogger("ConsoleApp.LoggingExample")</span>.
							For example: <span class="code">log4net.LogManager.GetLogger("ConsoleApp.LoggingExample").Info("Application Start");</span>
							The <span class="code">ILog</span> interface is actually an extension to log4net that provides level 
							specific logging methods (i.e. Debug, Info, Warn, Error, and Fatal).
						</p>
					</li>
					<li>
						<p>
							The message is then logged through to the <span class="code">ILogger.Log</span> method on the 
							appropriate <span class="code">log4net.Repository.Hierarchy.Logger</span> object. The 
							<span class="code">ILogger.Log</span> method takes the <span class="code">Level</span> to
							log at as a parameter and therefore works for all levels.
						</p>
					</li>
					<li>
						<p>
							The repository threshold level is compared to the message level to determine if the message 
							can be logged. If the message level is below the threshold level the message is not logged.
							In this case the repository is a <span class="code">log4net.Repository.Hierarchy</span> object.
						</p>
					</li>
					<li>
						<p>
							The <span class="code">Logger</span> level is compared to the message level to determine if the 
							message can be logged. Note that the <span class="code">Logger</span> level is inherited from a 
							parent <span class="code">Logger</span> if not specified explicitly for this <span class="code">Logger</span>.
							If the message level is below the <span class="code">Logger</span> level the message is not logged.
						</p>
					</li>
					<li>
						<p>
							A <span class="code">LoggingEvent</span> instance is created to encapsulate the message being logged.
						</p>
					</li>
					<li>
						<p>
							The list of appenders for the <span class="code">Logger</span> is built. This includes appenders 
							attached to parent <span class="code">Logger</span>s except where excluded by the 
							<span class="code">Logger.Additivity</span> property.
						</p>
					</li>
					<li>
						<p>
							The <span class="code">LoggingEvent</span> object is passed to the 
							<span class="code">IAppender.DoAppend</span> method for each appender.
						</p>
					</li>
				</ol>
				<p>
					For Each Appender that the <span class="code">LoggingEvent</span> is delivered to the following
					actions take place:
				</p>
				<ol>
					<li>
						<p>
							The appender threshold level is compared to the message level to determine if the message 
							can be logged. If the message level is below the threshold level the message is not logged.
						</p>
					</li>
					<li>
						<p>
							If the appender has a filter chain the <span class="code">LoggingEvent</span> is passed down the 
							filter chain which can decide if the message can be logged or not.
						</p>
					</li>
					<li>
						<p>
							Next an appender specific check is performed. Usually this check will verify that all the 
							required properties are set for the appender (e.g. a <span class="code">Layout</span> is set if required).
						</p>
					</li>
					<li>
						<p>
							The <span class="code">LoggingEvent</span> is passed to the appender specific 
							<span class="code">Append</span> method. What happens now is specific to the appender.
						</p>
					</li>
				</ol>
				<p>
					The following actions take place in the <span class="code">ConsoleAppender.Append</span> method:
				</p>
				<ol>
					<li>
						<p>
							The <span class="code">ConsoleAppender</span> uses a <span class="code">Layout</span> to 
							format the message as a string for display.
						</p>
					</li>
					<li>
						<p>
							The <span class="code">Layout</span> uses the <span class="code">LoggingEvent.RenderedMessage</span>
							property to get the string for the message object. This uses the registered 
							<span class="code">IObjectRenderer</span> for the type of the message object.
						</p>
					</li>
					<li>
						<p>
							The message text is displayed on the console using the <span class="code">Console.WriteLine</span> method.
						</p>
					</li>
				</ol>
			</div>
			<h2><a id="more-info"></a>More Information</h2>
			<div class="i1">
				<p>
					For more information on frameworks that log4net supports see the 
					<a href="framework-support.html">Framework Support</a> document.
				</p>
				<p>
					For answers to common questions see the 
					<a href="faq.html">Frequently Asked Questions</a> document.
				</p>
				<p>
					For more information on log4net see <a href="http://www.log4net.org">http://www.log4net.org</a>.
				</p>
				<p>
					The log4net project is hosted on sourceforge. The project page is at <a href="http://www.sourceforge.net/projects/log4net">
						http://www.sourceforge.net/projects/log4net</a>.
				</p>
				<p>
					Discussion on log4net and logging in general are held on the <i>log4net-users</i>
					mailing list. To subscribe to this list visit: <a href="http://lists.sourceforge.net/lists/listinfo/log4net-users">
						http://lists.sourceforge.net/lists/listinfo/log4net-users</a>.
				</p>
				<p>
					The log4net framework is based on log4j see <a href="http://jakarta.apache.org/log4j">
						http://jakarta.apache.org/log4j</a> for more information on log4j.
				</p>
			</div>
		</div>
		<div id="footer">Copyright (C) 2001-2003 Neoworks Limited. All Rights Reserved.</div>
	</body>
</html>
